---
name: "Build Containers"

on:
  workflow_dispatch:
  push:
    branches:
      - feature/boto
    tags:
      - '*'

jobs:
  build-containers-common:
    runs-on: ubuntu-latest
    outputs:
      containerver: ${{ steps.getcontainerver.outputs.containerver }}
    steps:
      - name: Get Container Version
        id: getcontainerver
        run: |
          # Use tag name if available, otherwise use commit SHA
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "containerver=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"
          else
            echo "containerver=${{ github.sha }}" >> "$GITHUB_OUTPUT"
          fi

  build-containers:
    needs: build-containers-common
    strategy:
      matrix:
        include:
          - runnertags: ubuntu-latest
            arch: amd64
          - runnertags: ubuntu-24.04-arm
            arch: arm64
    runs-on: ${{ matrix.runnertags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to ghcr
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Build and Push Image
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
          NEXT_PUBLIC_VERSION: ${{ github.ref_name }}
        run: |
          docker buildx build --platform linux/${{ matrix.arch }} \
            -f Dockerfile.dev \
            -t ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-${{ matrix.arch }} \
            --build-arg NEXT_PUBLIC_VERSION=${{ env.NEXT_PUBLIC_VERSION }} \
            --provenance=false --sbom=false \
            --output "type=registry,name=ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-${{ matrix.arch }}" .

  build-container-manifest:
    needs: [build-containers, build-containers-common]
    runs-on: ubuntu-latest
    steps:
      - name: Login to ghcr
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Create Docker Manifest
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
        run: |
          # Verify the architecture images
          echo "Verifying AMD64 image:"
          docker buildx imagetools inspect ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-amd64
          
          echo "Verifying ARM64 image:"
          docker buildx imagetools inspect ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-arm64
          
          # Try to remove any existing manifests first
          docker manifest rm ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }} || true
          docker manifest rm ghcr.io/soma-krd/boto.social:latest || true
          
          # Create and push the version-specific manifest
          docker manifest create ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }} \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-amd64 \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-arm64

          docker manifest push ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}

          # Create and push the latest manifest
          docker manifest create ghcr.io/soma-krd/boto.social:latest \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-amd64 \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-arm64

          docker manifest push ghcr.io/soma-krd/boto.social:latest

      - name: Verify Manifest
        run: |
          docker manifest inspect ghcr.io/soma-krd/boto.social:latest

  deploy-to-server:
    needs: [build-container-manifest, build-containers-common]
    runs-on: ubuntu-latest
    # Only deploy on push to main branch (not on tags)
    if: github.ref == 'refs/heads/feature/boto'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate Required Secrets
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
          # Pass secrets as environment variables for validation
          MAIN_SERVER_SSH_KEY: ${{ secrets.MAIN_SERVER_SSH_KEY }}
          MAIN_SERVER_IP: ${{ secrets.MAIN_SERVER_IP }}
          MAIN_SERVER_SSH_PORT: ${{ secrets.MAIN_SERVER_SSH_PORT }}
          MAIN_SERVER_SSH_USER: ${{ secrets.MAIN_SERVER_SSH_USER }}
          MAIN_SERVER_DEPLOY_PATH: ${{ secrets.MAIN_SERVER_DEPLOY_PATH }}
          NETWORK_NAME: ${{ secrets.NETWORK_NAME }}
          VAULT_URL: ${{ secrets.VAULT_URL }}
          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
        run: |
          set -euo pipefail
          
          echo "=== VALIDATING DEPLOYMENT SECRETS ==="
          echo ""
          
          # Required GitHub secrets for deployment
          REQUIRED_SECRETS=(
            "MAIN_SERVER_SSH_KEY"
            "MAIN_SERVER_IP"
            "MAIN_SERVER_SSH_PORT"
            "MAIN_SERVER_SSH_USER"
            "MAIN_SERVER_DEPLOY_PATH"
            "NETWORK_NAME"
            "VAULT_URL"
            "VAULT_TOKEN"
          )
          
          MISSING_SECRETS=()
          
          # Check GitHub secrets
          echo "üîç Checking GitHub secrets..."
          for secret in "${REQUIRED_SECRETS[@]}"; do
            secret_value="${!secret}"
            if [[ -z "$secret_value" ]]; then
              MISSING_SECRETS+=("$secret")
              echo "  ‚ùå $secret: MISSING"
            else
              # Mask sensitive values in output
              if [[ "$secret" == *"KEY"* ]] || [[ "$secret" == *"TOKEN"* ]]; then
                echo "  ‚úÖ $secret: SET (hidden)"
              else
                echo "  ‚úÖ $secret: SET"
              fi
            fi
          done
          
          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo ""
            echo "‚ùå ERROR: Missing required GitHub secrets:"
            printf '   - %s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo ""
          echo "========================================="
          echo "  ‚úÖ All secrets validated!"
          echo "========================================="
          echo "GitHub Secrets: ${#REQUIRED_SECRETS[@]} validated"
          echo "========================================="

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.MAIN_SERVER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ secrets.MAIN_SERVER_SSH_PORT }} -H ${{ secrets.MAIN_SERVER_IP }} >> ~/.ssh/known_hosts

      - name: SCP docker-compose.prod.yaml
        run: |
          scp -i ~/.ssh/deploy_key -P ${{ secrets.MAIN_SERVER_SSH_PORT }} docker-compose.prod.yaml ${{ secrets.MAIN_SERVER_SSH_USER }}@${{ secrets.MAIN_SERVER_IP }}:/home/soma/boto/

      - name: Deploy to Production Server via SSH
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
        run: |
          set -euo pipefail

          echo "=== DEPLOYING BOTO TO PRODUCTION ==="

          # Prepare variables
          IMAGE_TAG="${{ env.CONTAINERVER }}"
          VAULT_URL="${{ secrets.VAULT_URL }}"
          VAULT_TOKEN="${{ secrets.VAULT_TOKEN }}"
          VAULT_SECRET_PATH="boto/data/production"
          NETWORK_NAME="${{ secrets.NETWORK_NAME }}"

          # Deploy via SSH with heredoc (prevents variable expansion issues)
          ssh -i ~/.ssh/deploy_key \
              -p ${{ secrets.MAIN_SERVER_SSH_PORT }} \
              ${{ secrets.MAIN_SERVER_SSH_USER }}@${{ secrets.MAIN_SERVER_IP }} \
              bash -s -- \
              "$IMAGE_TAG" \
              "$VAULT_URL" \
              "$VAULT_TOKEN" \
              "$VAULT_SECRET_PATH" \
              "$NETWORK_NAME" <<'DEPLOY_SCRIPT'
            set -euo pipefail

            # Read arguments passed from GitHub Actions
            IMAGE_TAG="$1"
            VAULT_URL="$2"
            VAULT_TOKEN="$3"
            VAULT_SECRET_PATH="$4"
            NETWORK_NAME="$5"

            DEPLOY_PATH="/home/soma/boto"
            IMAGE="ghcr.io/soma-krd/boto.social:${IMAGE_TAG}"
            APP_NAME="boto-app"
            NEW_CONTAINER="${APP_NAME}-new"

            echo "========================================="
            echo "  Boto Production Deployment"
            echo "========================================="
            echo "Image: $IMAGE"
            echo "Deploy Path: $DEPLOY_PATH"
            echo "Vault URL: $VAULT_URL"
            echo "Vault Path: $VAULT_SECRET_PATH"
            echo "Network: $NETWORK_NAME"
            echo ""

            cd "$DEPLOY_PATH"
            echo "Changed to deploy path: $(pwd)"

            # Step 1: Fetch secrets from Vault
            echo "==> Step 1/7: Fetching secrets from Vault..."
            echo "Vault URL: ${VAULT_URL}/v1/${VAULT_SECRET_PATH}"
            SECRETS_JSON=$(curl -s -H "X-Vault-Token: $VAULT_TOKEN" "${VAULT_URL}/v1/${VAULT_SECRET_PATH}")
            echo "Vault response received (length: ${#SECRETS_JSON})"

            if [ -z "$SECRETS_JSON" ] || [ "$(echo "$SECRETS_JSON" | jq -r '.data.data')" == "null" ]; then
              echo "‚ùå Error: Failed to fetch secrets from Vault at path ${VAULT_SECRET_PATH}"
              echo "Raw response: $SECRETS_JSON"
              # Check if response contains errors (without exposing secrets)
              if echo "$SECRETS_JSON" | jq -e '.errors' >/dev/null 2>&1; then
                echo "Vault returned errors (check Vault permissions and path)"
              else
                echo "Vault returned empty or invalid response"
              fi
              exit 1
            fi

            echo "‚úÖ Vault response valid, processing secrets..."

            # Backup existing .env
            if [ -f .env ]; then
              cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
              echo "Backed up existing .env"
            fi

            # Generate .env file
            {
              echo "# Generated from Vault secrets - DO NOT EDIT MANUALLY"
              echo "# Generated at: $(date)"
              echo ""
              echo "$SECRETS_JSON" | jq -r '.data.data | to_entries[] | .key + "=" + (.value | tostring)'
            } > .env

            chmod 600 .env
            echo "‚úÖ Secrets fetched and .env created (keys: $(grep -c '^[^#]' .env))"

            # Parse DATABASE_URL to set POSTGRES_* variables for docker-compose
            DATABASE_URL=$(echo "$SECRETS_JSON" | jq -r '.data.data.DATABASE_URL')
            if [ -n "$DATABASE_URL" ] && [ "$DATABASE_URL" != "null" ]; then
              # Parse postgresql://user:pass@host:port/db
              POSTGRES_USER=$(echo "$DATABASE_URL" | sed 's|postgresql://\([^:]*\):.*|\1|')
              POSTGRES_PASSWORD=$(echo "$DATABASE_URL" | sed 's|postgresql://[^:]*:\([^@]*\)@.*|\1|')
              POSTGRES_DB=$(echo "$DATABASE_URL" | sed 's|.*/\([^/]*\)$|\1|')
              export POSTGRES_USER
              export POSTGRES_PASSWORD
              export POSTGRES_DB
              echo "‚úÖ Parsed DATABASE_URL and set POSTGRES_* variables"
              echo "  POSTGRES_USER: $POSTGRES_USER"
              echo "  POSTGRES_DB: $POSTGRES_DB"
            else
              echo "‚ùå DATABASE_URL not found in vault secrets"
              exit 1
            fi
            
            # Step 2: Prepare Docker Compose
            echo "==> Step 2/8: Preparing Docker Compose..."
            echo "Updating docker-compose.prod.yaml placeholder to ${IMAGE_TAG}"
            sed -i "s|placeholder|${IMAGE_TAG}|g" docker-compose.prod.yaml
            echo "‚úÖ Compose file updated"

            # Step 3: Pull latest image
            echo "==> Step 3/8: Pulling Docker image..."
            echo "Pulling image: ghcr.io/soma-krd/boto.social:${IMAGE_TAG}"
            docker pull "$IMAGE"
            echo "‚úÖ Image pulled"

            # Step 4: Start new container
            echo "==> Step 4/8: Starting new container..."
            if docker compose -f docker-compose.prod.yaml up -d; then
              echo "‚úÖ Compose up successful"
            else
              echo "‚ö†Ô∏è  Compose failed, falling back to docker run"
              # Stop any existing container
              docker stop boto-app || true
              docker rm boto-app || true
              # Run with docker run
              docker run -d --name boto-app --restart unless-stopped --env-file .env -v /home/soma/boto/uploads:/uploads -v /home/soma/boto/logs:/app/logs --network soma_somanet "$IMAGE"
              echo "‚úÖ Docker run successful"
            fi
            docker ps -f name=boto-app --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # Step 5: Wait for container to initialize
            echo "==> Step 5/8: Waiting for application to initialize..."
            sleep 15
            echo "Wait complete"

            # Step 6: Run migrations
            echo "==> Step 6/8: Running database migrations..."
            if docker exec boto-app sh -c "pnpm run prisma-db-push"; then
              echo "‚úÖ Migrations completed successfully"
            else
              echo "‚ö†Ô∏è  Migration command failed, but continuing"
            fi

            # Step 7: Health check
            echo "==> Step 7/7: Performing health checks using docker-compose..."

            echo "Waiting for both boto-app and boto-postgres to be healthy..."
            timeout=300
            elapsed=0

            while [ $elapsed -lt $timeout ]; do
              # Get health status using docker-compose ps
              health_status=$(docker compose -f docker-compose.prod.yaml ps --format json | jq -r '.[] | select(.Service == "boto-app" or .Service == "boto-postgres") | "\(.Service):\(.Health)"')

              app_healthy=$(echo "$health_status" | grep -c "boto-app:healthy" || true)
              postgres_healthy=$(echo "$health_status" | grep -c "boto-postgres:healthy" || true)

              if [ "$app_healthy" -eq 1 ] && [ "$postgres_healthy" -eq 1 ]; then
                echo "‚úÖ Both services are healthy"

                # Cleanup old images
                echo "Cleaning up old Docker images..."
                docker image prune -f >/dev/null 2>&1 || true

                echo ""
                echo "========================================="
                echo "  ‚úÖ Deployment Successful!"
                echo "========================================="
                echo "Image: $IMAGE"
                echo "Container: boto-app"
                echo "========================================="

                exit 0
              else
                echo "Waiting... Current status:"
                echo "$health_status"
              fi

              sleep 10
              elapsed=$((elapsed + 10))
            done

            # Health check failed
            echo "‚ùå Health check failed after $timeout seconds"
            echo "Container status:"
            docker compose -f docker-compose.prod.yaml ps --format "table {{.Name}}\t{{.Service}}\t{{.Status}}\t{{.Ports}}"
            echo "Container logs:"
            docker compose -f docker-compose.prod.yaml logs --tail 100 boto-app
            docker compose -f docker-compose.prod.yaml logs --tail 100 boto-postgres

            # Rollback
            echo "Rolling back - stopping failed container"
            docker compose -f docker-compose.prod.yaml down || true
            docker stop boto-app || true
            docker rm boto-app || true

            # Restore old .env if exists
            if [ -f .env.backup.* ]; then
              latest_backup=$(ls -t .env.backup.* | head -1)
              cp "$latest_backup" .env
              echo "Restored previous .env file from $latest_backup"
            else
              echo "No backup .env found to restore"
            fi

            echo "========================================="
            echo "  ‚ùå Deployment Failed!"
            echo "========================================="
            exit 1
          DEPLOY_SCRIPT
          
          # Cleanup SSH key
          rm ~/.ssh/deploy_key
          
          echo "‚úÖ Deployment process completed!"
