---
name: "Build Containers"

on:
  workflow_dispatch:
  push:
    branches:
      - feature/boto
    tags:
      - '*'

jobs:
  build-containers-common:
    runs-on: ubuntu-latest
    outputs:
      containerver: ${{ steps.getcontainerver.outputs.containerver }}
    steps:
      - name: Get Container Version
        id: getcontainerver
        run: |
          # Use tag name if available, otherwise use commit SHA
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "containerver=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"
          else
            echo "containerver=${{ github.sha }}" >> "$GITHUB_OUTPUT"
          fi

  build-containers:
    needs: build-containers-common
    strategy:
      matrix:
        include:
          - runnertags: ubuntu-latest
            arch: amd64
          - runnertags: ubuntu-24.04-arm
            arch: arm64
    runs-on: ${{ matrix.runnertags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to ghcr
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Build and Push Image
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
          NEXT_PUBLIC_VERSION: ${{ github.ref_name }}
        run: |
          docker buildx build --platform linux/${{ matrix.arch }} \
            -f Dockerfile.dev \
            -t ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-${{ matrix.arch }} \
            --build-arg NEXT_PUBLIC_VERSION=${{ env.NEXT_PUBLIC_VERSION }} \
            --provenance=false --sbom=false \
            --output "type=registry,name=ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-${{ matrix.arch }}" .

  build-container-manifest:
    needs: [build-containers, build-containers-common]
    runs-on: ubuntu-latest
    steps:
      - name: Login to ghcr
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Create Docker Manifest
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
        run: |
          # Verify the architecture images
          echo "Verifying AMD64 image:"
          docker buildx imagetools inspect ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-amd64
          
          echo "Verifying ARM64 image:"
          docker buildx imagetools inspect ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-arm64
          
          # Try to remove any existing manifests first
          docker manifest rm ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }} || true
          docker manifest rm ghcr.io/soma-krd/boto.social:latest || true
          
          # Create and push the version-specific manifest
          docker manifest create ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }} \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-amd64 \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-arm64

          docker manifest push ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}

          # Create and push the latest manifest
          docker manifest create ghcr.io/soma-krd/boto.social:latest \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-amd64 \
            --amend ghcr.io/soma-krd/boto.social:${{ env.CONTAINERVER }}-arm64

          docker manifest push ghcr.io/soma-krd/boto.social:latest

      - name: Verify Manifest
        run: |
          docker manifest inspect ghcr.io/soma-krd/boto.social:latest

  deploy-to-server:
    needs: [build-container-manifest, build-containers-common]
    runs-on: ubuntu-latest
    # Only deploy on push to main branch (not on tags)
    if: github.ref == 'refs/heads/feature/boto'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate Required Secrets
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
          # Pass secrets as environment variables for validation
          MAIN_SERVER_SSH_KEY: ${{ secrets.MAIN_SERVER_SSH_KEY }}
          MAIN_SERVER_IP: ${{ secrets.MAIN_SERVER_IP }}
          MAIN_SERVER_SSH_PORT: ${{ secrets.MAIN_SERVER_SSH_PORT }}
          MAIN_SERVER_SSH_USER: ${{ secrets.MAIN_SERVER_SSH_USER }}
          MAIN_SERVER_DEPLOY_PATH: ${{ secrets.MAIN_SERVER_DEPLOY_PATH }}
          NETWORK_NAME: ${{ secrets.NETWORK_NAME }}
          VAULT_URL: ${{ secrets.VAULT_URL }}
          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
        run: |
          set -euo pipefail
          
          echo "=== VALIDATING DEPLOYMENT SECRETS ==="
          echo ""
          
          # Required GitHub secrets for deployment
          REQUIRED_SECRETS=(
            "MAIN_SERVER_SSH_KEY"
            "MAIN_SERVER_IP"
            "MAIN_SERVER_SSH_PORT"
            "MAIN_SERVER_SSH_USER"
            "MAIN_SERVER_DEPLOY_PATH"
            "NETWORK_NAME"
            "VAULT_URL"
            "VAULT_TOKEN"
          )
          
          MISSING_SECRETS=()
          
          # Check GitHub secrets
          echo "üîç Checking GitHub secrets..."
          for secret in "${REQUIRED_SECRETS[@]}"; do
            secret_value="${!secret}"
            if [[ -z "$secret_value" ]]; then
              MISSING_SECRETS+=("$secret")
              echo "  ‚ùå $secret: MISSING"
            else
              # Mask sensitive values in output
              if [[ "$secret" == *"KEY"* ]] || [[ "$secret" == *"TOKEN"* ]]; then
                echo "  ‚úÖ $secret: SET (hidden)"
              else
                echo "  ‚úÖ $secret: SET"
              fi
            fi
          done
          
          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo ""
            echo "‚ùå ERROR: Missing required GitHub secrets:"
            printf '   - %s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo ""
          echo "========================================="
          echo "  ‚úÖ All secrets validated!"
          echo "========================================="
          echo "GitHub Secrets: ${#REQUIRED_SECRETS[@]} validated"
          echo "========================================="

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.MAIN_SERVER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ secrets.MAIN_SERVER_SSH_PORT }} -H ${{ secrets.MAIN_SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Deploy to Production Server via SSH
        env:
          CONTAINERVER: ${{ needs.build-containers-common.outputs.containerver }}
        run: |
          set -euo pipefail

          echo "=== DEPLOYING BOTO TO PRODUCTION ==="

          # Prepare variables
          IMAGE_TAG="${{ env.CONTAINERVER }}"
          DEPLOY_PATH="${{ secrets.MAIN_SERVER_DEPLOY_PATH }}"
          VAULT_URL="${{ secrets.VAULT_URL }}"
          VAULT_TOKEN="${{ secrets.VAULT_TOKEN }}"
          VAULT_SECRET_PATH="boto/data/production"
          NETWORK_NAME="${{ secrets.NETWORK_NAME }}"

          # Deploy via SSH with heredoc (prevents variable expansion issues)
          ssh -i ~/.ssh/deploy_key \
              -p ${{ secrets.MAIN_SERVER_SSH_PORT }} \
              ${{ secrets.MAIN_SERVER_SSH_USER }}@${{ secrets.MAIN_SERVER_IP }} \
              bash -s -- \
              "$IMAGE_TAG" \
              "$DEPLOY_PATH" \
              "$VAULT_URL" \
              "$VAULT_TOKEN" \
              "$VAULT_SECRET_PATH" \
              "$NETWORK_NAME" <<'DEPLOY_SCRIPT'
            set -euo pipefail
            
            # Read arguments passed from GitHub Actions
            IMAGE_TAG="$1"
            DEPLOY_PATH="$2"
            VAULT_URL="$3"
            VAULT_TOKEN="$4"
            VAULT_SECRET_PATH="$5"
            NETWORK_NAME="$6"
            
            IMAGE="ghcr.io/soma-krd/boto.social:${IMAGE_TAG}"
            APP_NAME="boto-app"
            NEW_CONTAINER="${APP_NAME}-new"
            
            echo "========================================="
            echo "  Boto Production Deployment"
            echo "========================================="
            echo "Image: $IMAGE"
            echo "Deploy Path: $DEPLOY_PATH"
            echo ""
            
            cd "$DEPLOY_PATH"

            # Create Docker Compose file
            cat > docker-compose.dev.yaml << 'COMPOSE_EOF'
services:
 boto-postgres:
   image: postgres:15
   container_name: boto-postgres
   restart: always
   environment:
     POSTGRES_USER: boto
     POSTGRES_PASSWORD: dfj02idkn209dfg5536dfg21s3
     POSTGRES_DB: boto
   volumes:
     - ./postgres_data:/var/lib/postgresql/data
   networks:
     - soma_somanet
 boto-redis:
   image: redis:7
   container_name: boto-redis
   restart: always
   volumes:
     - ./redis_data:/data
   networks:
     - soma_somanet
 boto-pg-admin:
   image: dpage/pgadmin4:latest
   container_name: boto-pg-admin
   restart: always
   environment:
     PGADMIN_DEFAULT_EMAIL: admin@soma.krd
     PGADMIN_DEFAULT_PASSWORD: dfj02idkn209dPo04ndfkgsK
   volumes:
     - ./pgadmin_data:/var/lib/pgadmin
   networks:
     - soma_somanet
 boto-app:
   image: ghcr.io/soma-krd/boto.social:placeholder
   container_name: boto-app
   restart: unless-stopped
   env_file:
     - .env
   volumes:
     - ./uploads:/uploads
     - ./logs:/app/logs
   networks:
     - soma_somanet

networks:
 soma_somanet:
   external: true
EOF

            # Step 1: Fetch secrets from Vault
            echo "==> Step 1/7: Fetching secrets from Vault..."
            SECRETS_JSON=$(curl -s -H "X-Vault-Token: $VAULT_TOKEN" "${VAULT_URL}/v1/${VAULT_SECRET_PATH}")
            
            if [ -z "$SECRETS_JSON" ] || [ "$(echo "$SECRETS_JSON" | jq -r '.data.data')" == "null" ]; then
              echo "‚ùå Error: Failed to fetch secrets from Vault at path ${VAULT_SECRET_PATH}"
              # Check if response contains errors (without exposing secrets)
              if echo "$SECRETS_JSON" | jq -e '.errors' >/dev/null 2>&1; then
                echo "Vault returned errors (check Vault permissions and path)"
              else
                echo "Vault returned empty or invalid response"
              fi
              exit 1
            fi
            
            # Backup existing .env
            if [ -f .env ]; then
              cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
            fi
            
            # Generate .env file
            {
              echo "# Generated from Vault secrets - DO NOT EDIT MANUALLY"
              echo "# Generated at: $(date)"
              echo ""
              echo "$SECRETS_JSON" | jq -r '.data.data | to_entries[] | .key + "=" + (.value | tostring)'
            } > .env
            
            chmod 600 .env
            echo "‚úÖ Secrets fetched and .env created"
            
            # Step 2: Prepare Docker Compose
            echo "==> Step 2/7: Preparing Docker Compose..."
            sed -i "s/placeholder/${IMAGE_TAG}/" docker-compose.dev.yaml
            echo "‚úÖ Compose file updated"

            # Step 3: Pull latest image
            echo "==> Step 3/7: Pulling Docker image..."
            docker compose -f docker-compose.dev.yaml pull boto-app
            echo "‚úÖ Image pulled"

            # Step 4: Start new container
            echo "==> Step 4/7: Starting new container..."
            docker compose -f docker-compose.dev.yaml up -d boto-app
            echo "‚úÖ New container started"

            # Step 5: Wait for container to initialize
            echo "==> Step 5/7: Waiting for application to initialize..."
            sleep 15

            # Step 6: Run migrations
            echo "==> Step 6/7: Running database migrations..."
            docker exec boto-app sh -c "pnpm run prisma-db-push" || {
              echo "‚ö†Ô∏è  Migration command failed, but continuing"
            }
            echo "‚úÖ Migrations completed"

            # Step 7: Health check
            echo "==> Step 7/7: Performing health checks..."

            FRONTEND_URL="http://localhost:4200"
            BACKEND_URL="http://localhost:3000"

            for i in {1..30}; do
              # Check if container is still running
              if ! docker ps -q -f name="^boto-app$" | grep -q .; then
                echo "‚ùå Container boto-app stopped unexpectedly"
                docker logs --tail 50 boto-app || true
                exit 1
              fi

              # Check frontend health
              if docker exec boto-app curl -fs "$FRONTEND_URL" >/dev/null 2>&1; then
                # Check backend health
                if docker exec boto-app curl -fs "$BACKEND_URL" >/dev/null 2>&1; then
                  echo "‚úÖ New container is healthy (Frontend & Backend)"

                  # Cleanup old images
                  echo "Cleaning up old Docker images..."
                  docker image prune -f >/dev/null 2>&1 || true

                  echo ""
                  echo "========================================="
                  echo "  ‚úÖ Deployment Successful!"
                  echo "========================================="
                  echo "Image: $IMAGE"
                  echo "Container: boto-app"
                  echo "========================================="

                  exit 0
                fi
              fi

              echo "Attempt $i/30: Waiting for health check..."
              sleep 2
            done

            # Health check failed
            echo "‚ùå Health check failed after 30 attempts"
            echo "Container logs:"
            docker logs --tail 100 boto-app

            # Rollback
            echo "Rolling back - stopping failed container"
            docker compose -f docker-compose.dev.yaml stop boto-app || true
            docker compose -f docker-compose.dev.yaml rm boto-app || true

            # Restore old .env if exists
            if [ -f .env.backup.* ]; then
              latest_backup=$(ls -t .env.backup.* | head -1)
              cp "$latest_backup" .env
              echo "Restored previous .env file"
            fi

            exit 1
          DEPLOY_SCRIPT
          
          # Cleanup SSH key
          rm ~/.ssh/deploy_key
          
          echo "‚úÖ Deployment process completed!"
